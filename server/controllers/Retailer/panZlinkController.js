const moment = require("moment-timezone");
const { db } = require("../../connect");
const axios = require("axios");
const dotenv = require("dotenv");
const { param } = require("../../routers/Retailer/deeperwebRouter");
dotenv.config();


const zlinkBaseURL = process.env.zlinkBaseurl;
const Token = process.env.zlinkToken;
const zlinkApiKey = process.env.zlink_api_key;
const apiClient = axios.create({
  baseURL: zlinkBaseURL,
});


// const getDataFromZlinkPANApi = (endpoint, bodyData  = {}) => {
//     return apiClient
//       .post(endpoint, bodyData )
//       .then((response) => {
//         return response.data;
//       })
//       .catch((error) => {
//         console.error("Error fetching data from client API:", error.message);
//         throw error;
//       });
//   };

const getDataFromZlinkPANApi = async (endpoint, bodyData  = {}) => {
  try {
  const response = await apiClient
    .post(endpoint, bodyData);
  return response.data;
} catch (error) {
  console.error("Error fetching data from client API:", error.message);
  throw error;
}
};
  
  const zlinkBalance = (req, res) => {
    
    const endpoint = "/user/balance-check";
  
    getDataFromZlinkPANApi(endpoint,  {
        token : Token
    })
      .then((data) => {
        res.json(data);
      })
      .catch((error) => {
        console.error(
          "Error details:",
          error.response ? error.response.data : error.message
        );
        res.status(500).send("Error fetching data from client API");
      });
  };

  const zlinkBalanceForPan = async () => {
    const endpoint = "/user/balance-check";
    try {
      const data = await getDataFromZlinkPANApi(endpoint, { token: Token });
      return data;
    } catch (error) {
      console.error("Error details:", error.response ? error.response.data : error.message);
      throw new Error("Error fetching balance from client API");
    }
  };



//   const zlinkNewPanRequest = async (req, res) => {
//     try {
//       const {app_mode, selectType,phyPanIsReq, redirect_url,first_name,middle_name,last_name,gender,dob,mobile_no,email_id,pan_no,walletDeductAmt,userId,branchCode } = req.body;

//      // Try to get balance, handle errors if they occur
//      let balanceData;
//      try {
//        balanceData = await zlinkBalanceForPan(); // Wait for the balance data
      
//      } catch (error) {
//        console.error("Error fetching balance:", error.message);
//        return res.status(500).json({ error: "Error fetching balance data" });
//      }
//       if (!balanceData || balanceData.user_balance < walletDeductAmt) {
//         return res.status(400).json({ error: "Insufficient balance" });
//       }

//       if(
//         !app_mode ||
//         !redirect_url ||
//         !first_name ||
//         !last_name ||
//         !dob ||
//         !gender ||
//         !mobile_no ||
//         !email_id ||
//         !phyPanIsReq ||
//         !selectType ||
//         !walletDeductAmt ||
//         !userId
//       ){
//         return res.status(400).json({ error: "All fields are required" });
//       }

//       let applicationMode ;
//       if(app_mode == 'Instant PAN Card - EKYC'){
//         applicationMode = "E"
//       }
//       else if(app_mode == 'Scan Based PAN Card'){
//         applicationMode = "K"
//       }

//       let physicalPanReq ;

//       if(phyPanIsReq == 'Yes'){
//         physicalPanReq = "Y"
//       }
//       else{
//         physicalPanReq = "N"
//       }
//       const endpoint = "/nsdl/request";
//       const createdAt = moment().tz("Asia/Kolkata").format("YYYY-MM-DD HH:mm:ss");
//       const fullName = first_name + " " + middle_name + " " + last_name;
//       // Insert initial row to generate orderid
//     const insertQuery = `INSERT INTO nsdlpan (applicationMode, selectType, name, dob, gender, mobile, email, physicalPan, walletDeductAmt, providerName, userId, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
//     const values = [
//       app_mode,
//       selectType,
//       fullName,
//       dob,
//       gender,
//       mobile_no,
//       email_id,
//       phyPanIsReq,
//       walletDeductAmt,
//       "Zlink",
//       userId,
//       createdAt,
//     ];


//     const result = await new Promise((resolve, reject) => {
//       db.query(insertQuery, values, (err, result) => {
//         if (err) return reject(err);
//         resolve(result);
//       });
//     });

//     const autoGeneratedOrderId = result.insertId;
//     const formattedOrderId = String(autoGeneratedOrderId).padStart(6, "0");

//     const nsdlData = await getDataFromZlinkPANApi(endpoint,  {
//       api_key : zlinkApiKey,
//       env_mode : "LIVE",
//       app_type : "NEW",
//       app_mode : applicationMode ,
//       phyPanIsReq: physicalPanReq,
//       branchCode,
//       redirect_url,
//       order_id: formattedOrderId,
//       applicant_data : {
//           first_name,
//           middle_name,
//           last_name,
//           gender,
//           dob,
//           mobile_no,
//           email_id,
//           pan_no
//         }
//  })

//  // Update the database with API response data
//  const updateQuery = `
//  UPDATE nsdlpan SET txid = ?, status = ?, message = ?, orderid = ? WHERE id = ?`;
// const updateValues = [
//  nsdlData?.txnid,
//  nsdlData?.status,
//  nsdlData?.message,
//  formattedOrderId, // Use the generated orderid if not returned from API
//  autoGeneratedOrderId, // Use the database id for updating
// ];

// await new Promise((resolve, reject) => {
//  db.query(updateQuery, updateValues, (err, result) => {
//    if (err) return reject(err);
//    resolve(result);
//  });
// });


//  if( nsdlData.status == "Success"){
//  return  res.json({
//     message: "Success",
//     nsdlData,
//     orderid: formattedOrderId, // Include the generated orderid in the response
//   });

//  }
//  return res.json({
//   message: "Failed",
//   nsdlData,
//   orderid: formattedOrderId, // Include the generated orderid in the response
// });

      
//     } catch (error) {
//       console.error("Error in nsdlNewRequest:", error);
//     res
//       .status(500)
//       .json({ error: "Error during recharge process", message: error.message });
//     }
   
  
     
      
//   };
  const zlinkNewPanRequest = async (req, res) => {
    
      const {app_mode, selectType,phyPanIsReq, redirect_url,first_name,middle_name,last_name,gender,dob,mobile_no,email_id,pan_no,walletDeductAmt,userId,branchCode } = req.body;

      let applicationMode ;
      if(app_mode == 'Instant PAN Card - EKYC'){
        applicationMode = "E"
      }
      else if(app_mode == 'Scan Based PAN Card'){
        applicationMode = "K"
      }

      let physicalPanReq ;

      if(phyPanIsReq == 'Yes'){
        physicalPanReq = "Y"
      }
      else{
        physicalPanReq = "N"
      }
      const endpoint = "/nsdl/request";
     
  if (walletDeductAmt == null || isNaN(parseFloat(walletDeductAmt)) || parseFloat(walletDeductAmt) < 0) {
    return res.status(400).json({ status: "failure", error: "Invalid or missing walletDeductAmt" });
  }
  const AmountNumber = parseFloat(walletDeductAmt).toFixed(2);
  const createdAt = moment().tz("Asia/Kolkata").format("YYYY-MM-DD HH:mm:ss");
  const queryBalance = `SELECT Closing_Balance FROM user_wallet WHERE userId = ? ORDER BY STR_TO_DATE(transaction_date, '%Y-%m-%d %H:%i:%s') DESC LIMIT 1`;
  db.query(queryBalance, [userId], (err, balanceResult) => {
    if (err) {
      return res.status(500).json({ error: "Error fetching wallet balance", message: err.message });
    }
    if (balanceResult.length === 0 || parseFloat(balanceResult[0].Closing_Balance) < AmountNumber) {
      return res.status(400).json({ error: "Insufficient wallet balance" });
    }

    const currentBalance = parseFloat(balanceResult[0].Closing_Balance);
    const orderId = `ORPAN${Date.now()}`;






     // Try to get balance, handle errors if they occur
     
     zlinkBalanceForPan().then((balanceData) => {
      if (!balanceData || parseFloat(balanceData.user_balance) < AmountNumber) {
        return Promise.reject({ status: 400, error: "Insufficient provider balance" });
      }
     

      if(
        !app_mode ||
        !redirect_url ||
        !first_name ||
        !last_name ||
        !dob ||
        !gender ||
        !mobile_no ||
        !email_id ||
        !phyPanIsReq ||
        !selectType ||
        !walletDeductAmt ||
        !userId
      ){
        return res.status(400).json({ error: "All fields are required" });
      }

     
      
      const fullName = first_name + " " + middle_name + " " + last_name;
      // Insert initial row to generate orderid
    const insertQuery = `INSERT INTO nsdlpan (applicationMode, selectType, name, dob, gender, mobile, email, physicalPan, walletDeductAmt, providerName, userId,orderid, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)`;
    const values = [
      app_mode,
      selectType,
      fullName,
      dob,
      gender,
      mobile_no,
      email_id,
      phyPanIsReq,
      walletDeductAmt,
      "Zlink",
      userId,
      orderId,
      createdAt,
    ];


   return new Promise((resolve, reject) => {
    db.query(insertQuery, values, (err) => {
      if (err) {
        reject({ status: 500, error: "Database insertion error", message: err.message });
      } else {
        resolve({ orderId });
      }
    });
  });
    }).then(({orderId})=>{
      return getDataFromZlinkPANApi(
        endpoint,  {
          api_key : zlinkApiKey,
          env_mode : "LIVE",
          app_type : "NEW",
          app_mode : applicationMode ,
          phyPanIsReq: physicalPanReq,
          branchCode,
          redirect_url,
          order_id: orderId,
          applicant_data : {
              first_name,
              middle_name,
              last_name,
              gender,
              dob,
              mobile_no,
              email_id,
              pan_no
            }
     }
      ).then((nsdlData) => ({ nsdlData, orderId }));
    }).then(({nsdlData, orderId}) => {
      const updateQuery = `
      UPDATE nsdlpan SET txid = ?, status = ?, message = ?  WHERE orderid = ?`;
     const updateValues = [
      nsdlData?.txnid,
      nsdlData?.status,
      nsdlData?.message,
       // Use the generated orderid if not returned from API
       orderId // Use the database id for updating
     ];
     
     return new Promise((resolve, reject) => {
      db.query(updateQuery, updateValues, (err, result) => {
        if (err) {
          reject({ status: 500, error: "Failed to update NSDL data", message: err.message });
        } else {
          resolve({ nsdlData, orderId, newBalance: (currentBalance - walletDeductAmt).toFixed(2) });
        }
      });
     });
    }).then(({nsdlData, orderId, newBalance}) =>{
      if (nsdlData.status === "Success" || nsdlData.status === "Pending") {
        const transactionId = `TXNPAN${Date.now()}`;
        const transactionDetails = `NSDL PAN Deduction Order Id ${orderId}`;
        const updateWalletQuery = `INSERT INTO user_wallet (userId, transaction_date, Order_Id, Transaction_Id, Opening_Balance, Closing_Balance, Transaction_Type, credit_amount, debit_amount, Transaction_details, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
        return new Promise((resolve, reject) => {
          db.query(updateWalletQuery, [userId, createdAt, orderId, transactionId, currentBalance.toFixed(2), newBalance, "Debit", 0, walletDeductAmt, transactionDetails, "Success"], (err) => {
            if (err) {
              reject({ status: 500, error: "Failed to update wallet balance", message: err.message });
            } else {
              resolve({ message: nsdlData.status === "Success" ? "Successful" : "Recharge failed", nsdlData, wallet: { previousBalance: currentBalance.toFixed(2), newBalance }, orderId });
            }
          });
        });
      } else {
        return Promise.resolve({ message: "Recharge failed", nsdlData, wallet: { previousBalance: currentBalance.toFixed(2), newBalance: currentBalance.toFixed(2) }, orderId });
      }
    }).then((finalResult) => {
      res.json(finalResult);
    })
    .catch((error) => {
      console.error("Caught an error in the promise chain:", error);
      res.status(error.status || 500).json({ error: error.error || "Request failed", message: error.message || "Unknown error" });
    });
});
};

    // const autoGeneratedOrderId = result.insertId;
    // const formattedOrderId = String(autoGeneratedOrderId).padStart(6, "0");

 // Update the database with API response data




//   const zlinkCorrectionPanRequest = async (req, res) => {
//     try {
//       const {app_mode, selectType,phyPanIsReq, redirect_url,first_name,middle_name,last_name,gender,dob,mobile_no,email_id,pan_no,walletDeductAmt,userId, branchCode } = req.body;

//      // Try to get balance, handle errors if they occur
//      let balanceData;
//      try {
//        balanceData = await zlinkBalanceForPan(); // Wait for the balance data
      
//      } catch (error) {
//        console.error("Error fetching balance:", error.message);
//        return res.status(500).json({ error: "Error fetching balance data" });
//      }
//       if (!balanceData || balanceData.user_balance < walletDeductAmt) {
//         return res.status(400).json({ error: "Insufficient balance" });
//       }

//       if(
//         !app_mode ||
//         !redirect_url ||
//         !first_name ||
//         !last_name ||
//         !dob ||
//         !gender ||
//         !mobile_no ||
//         !email_id ||
//         !phyPanIsReq ||
//         !selectType ||
//         !walletDeductAmt ||
//         !pan_no ||
//         !userId
//       ){
//         return res.status(400).json({ error: "All fields are required" });
//       }

//       let applicationMode ;
//       if(app_mode == 'Instant PAN Card - EKYC'){
//         applicationMode = "E"
//       }
//       else if(app_mode == 'Scan Based PAN Card'){
//         applicationMode = "K"
//       }

//       let physicalPanReq ;

//       if(phyPanIsReq == 'Yes'){
//         physicalPanReq = "Y"
//       }
//       else{
//         physicalPanReq = "N"
//       }
//       const endpoint = "/nsdl/request";
//       const createdAt = moment().tz("Asia/Kolkata").format("YYYY-MM-DD HH:mm:ss");
//       const fullName = first_name + " " + middle_name + " " + last_name;
//       // Insert initial row to generate orderid
//     const insertQuery = `INSERT INTO nsdlpancorrection (applicationMode, selectType, name, dob, gender, mobile, email, pan_no, physicalPan, walletDeductAmt, providerName, userId, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
//     const values = [
//       app_mode,
//       selectType,
//       fullName,
//       dob,
//       gender,
//       mobile_no,
//       email_id,
//       pan_no,
//       phyPanIsReq,
//       walletDeductAmt,
//       "zlink",
//       userId,
//       createdAt,
//     ];


//     const result = await new Promise((resolve, reject) => {
//       db.query(insertQuery, values, (err, result) => {
//         if (err) return reject(err);
//         resolve(result);
//       });
//     });

//     const autoGeneratedOrderId = result.insertId;
//     const formattedOrderId = String(autoGeneratedOrderId).padStart(6, "0");

//     const nsdlData = await getDataFromZlinkPANApi(endpoint,  {
//       api_key : zlinkApiKey,
//       env_mode : "LIVE",
//       app_type : "CR",
//       app_mode : applicationMode ,
//       phyPanIsReq: physicalPanReq,
//       branchCode,
//       redirect_url,
//       order_id: formattedOrderId,
//       applicant_data : {
//           first_name,
//           middle_name,
//           last_name,
//           gender,
//           dob,
//           mobile_no,
//           email_id,
//           pan_no
//         }
//  })

//  // Update the database with API response data
//  const updateQuery = `
//  UPDATE nsdlpancorrection SET txid = ?, status = ?, message = ?, orderid = ? WHERE id = ?`;
// const updateValues = [
//  nsdlData?.txnid,
//  nsdlData?.status,
//  nsdlData?.message,
//  formattedOrderId, // Use the generated orderid if not returned from API
//  autoGeneratedOrderId, // Use the database id for updating
// ];

// await new Promise((resolve, reject) => {
//  db.query(updateQuery, updateValues, (err, result) => {
//    if (err) return reject(err);
//    resolve(result);
//  });
// });


//  if( nsdlData.status == "Success"){
//  return res.json({
//     message: "Success",
//     nsdlData,
//     orderid: formattedOrderId, // Include the generated orderid in the response
//   });

//  }
// return res.json({
//   message: "Failed",
//   nsdlData,
//   orderid: formattedOrderId, // Include the generated orderid in the response
// });

      
//     } catch (error) {
//       console.error("Error in nsdlNewRequest:", error);
//     res
//       .status(500)
//       .json({ error: "Error during recharge process", message: error.message });
//     }
   
  
     
      
//   };

const zlinkCorrectionPanRequest = async (req, res) => {
    
  const {app_mode, selectType,phyPanIsReq, redirect_url,first_name,middle_name,last_name,gender,dob,mobile_no,email_id,pan_no,walletDeductAmt,userId, branchCode } = req.body;

  let applicationMode ;
  if(app_mode == 'Instant PAN Card - EKYC'){
    applicationMode = "E"
  }
  else if(app_mode == 'Scan Based PAN Card'){
    applicationMode = "K"
  }

  let physicalPanReq ;

  if(phyPanIsReq == 'Yes'){
    physicalPanReq = "Y"
  }
  else{
    physicalPanReq = "N"
  }
  const endpoint = "/nsdl/request";
 
if (walletDeductAmt == null || isNaN(parseFloat(walletDeductAmt)) || parseFloat(walletDeductAmt) < 0) {
return res.status(400).json({ status: "failure", error: "Invalid or missing walletDeductAmt" });
}
const AmountNumber = parseFloat(walletDeductAmt).toFixed(2);
const createdAt = moment().tz("Asia/Kolkata").format("YYYY-MM-DD HH:mm:ss");
const queryBalance = `SELECT Closing_Balance FROM user_wallet WHERE userId = ? ORDER BY STR_TO_DATE(transaction_date, '%Y-%m-%d %H:%i:%s') DESC LIMIT 1`;
db.query(queryBalance, [userId], (err, balanceResult) => {
if (err) {
  return res.status(500).json({ error: "Error fetching wallet balance", message: err.message });
}
if (balanceResult.length === 0 || parseFloat(balanceResult[0].Closing_Balance) < AmountNumber) {
  return res.status(400).json({ error: "Insufficient wallet balance" });
}

const currentBalance = parseFloat(balanceResult[0].Closing_Balance);
const orderId = `ORPAN${Date.now()}`;






 // Try to get balance, handle errors if they occur
 
 zlinkBalanceForPan().then((balanceData) => {
  if (!balanceData || parseFloat(balanceData.user_balance) < AmountNumber) {
    return Promise.reject({ status: 400, error: "Insufficient provider balance" });
  }
 

  if(
    !app_mode ||
    !redirect_url ||
    !first_name ||
    !last_name ||
    !dob ||
    !gender ||
    !mobile_no ||
    !email_id ||
    !phyPanIsReq ||
    !selectType ||
    !walletDeductAmt ||
    !userId
  ){
    return res.status(400).json({ error: "All fields are required" });
  }

 
  
  const fullName = first_name + " " + middle_name + " " + last_name;
  // Insert initial row to generate orderid
const insertQuery = `INSERT INTO nsdlpancorrection (applicationMode, selectType, name, dob, gender, mobile, email,pan_no, physicalPan, walletDeductAmt, providerName, userId,orderid, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?)`;
const values = [
  app_mode,
  selectType,
  fullName,
  dob,
  gender,
  mobile_no,
  email_id,
  pan_no,
  phyPanIsReq,
  walletDeductAmt,
  "zlink",
  userId,
  orderId,
  createdAt,
];


return new Promise((resolve, reject) => {
db.query(insertQuery, values, (err) => {
  if (err) {
    reject({ status: 500, error: "Database insertion error", message: err.message });
  } else {
    resolve({ orderId });
  }
});
});
}).then(({orderId})=>{
  return getDataFromZlinkPANApi(
    endpoint,  {
      api_key : zlinkApiKey,
      env_mode : "LIVE",
      app_type : "CR",
      app_mode : applicationMode ,
      phyPanIsReq: physicalPanReq,
      branchCode,
      redirect_url,
      order_id: orderId,
      applicant_data : {
          first_name,
          middle_name,
          last_name,
          gender,
          dob,
          mobile_no,
          email_id,
          pan_no
        }
 }
  ).then((nsdlData) => ({ nsdlData, orderId }));
}).then(({nsdlData, orderId}) => {
  const updateQuery = `
  UPDATE nsdlpancorrection SET txid = ?, status = ?, message = ?  WHERE orderid = ?`;
 const updateValues = [
  nsdlData?.txnid,
  nsdlData?.status,
  nsdlData?.message,
   // Use the generated orderid if not returned from API
   orderId // Use the database id for updating
 ];
 
 return new Promise((resolve, reject) => {
  db.query(updateQuery, updateValues, (err, result) => {
    if (err) {
      reject({ status: 500, error: "Failed to update NSDL data", message: err.message });
    } else {
      resolve({ nsdlData, orderId, newBalance: (currentBalance - walletDeductAmt).toFixed(2) });
    }
  });
 });
}).then(({nsdlData, orderId, newBalance}) =>{
  if (nsdlData.status === "Success" || nsdlData.status === "Pending") {
    const transactionId = `TXNPAN${Date.now()}`;
    const transactionDetails = `NSDL PAN Correction Deduction Order Id ${orderId}`;
    const updateWalletQuery = `INSERT INTO user_wallet (userId, transaction_date, Order_Id, Transaction_Id, Opening_Balance, Closing_Balance, Transaction_Type, credit_amount, debit_amount, Transaction_details, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
    return new Promise((resolve, reject) => {
      db.query(updateWalletQuery, [userId, createdAt, orderId, transactionId, currentBalance.toFixed(2), newBalance, "Debit", 0, walletDeductAmt, transactionDetails, "Success"], (err) => {
        if (err) {
          reject({ status: 500, error: "Failed to update wallet balance", message: err.message });
        } else {
          resolve({ message: nsdlData.status === "Success" ? "Successful" : "Recharge failed", nsdlData, wallet: { previousBalance: currentBalance.toFixed(2), newBalance }, orderId });
        }
      });
    });
  } else {
    return Promise.resolve({ message: "Recharge failed", nsdlData, wallet: { previousBalance: currentBalance.toFixed(2), newBalance: currentBalance.toFixed(2) }, orderId });
  }
}).then((finalResult) => {
  res.json(finalResult);
})
.catch((error) => {
  console.error("Caught an error in the promise chain:", error);
  res.status(error.status || 500).json({ error: error.error || "Request failed", message: error.message || "Unknown error" });
});
});
};


  const zlinkIncompletePan = async (req,res) => {
    const endpoint = "/nsdl/inc-request";
    const {order_id} = req.body;
    try {
      const data = await getDataFromZlinkPANApi(endpoint, { 
        api_key : zlinkApiKey,
        order_id ,
        request_from : "WEB"
       });
      return res.status(200).json({
        status : "Success",
        message: "Success",
        data,
      })
    } catch (error) {
      console.error("Error details:", error.response ? error.response.data : error.message);
      return res.status(500).json({ status : "failed", error: "Error from api" });
    }
  };
  
  const zlinkPantxnStatus = async (req,res)=>{
         const {order_id} = req.body
         const endpoint = "/nsdl/txn-status"
         try {
           const data = await getDataFromZlinkPANApi(endpoint, {
            api_key : zlinkApiKey,
            order_id 
           })
          
          return res.status(200).json({status : "Success",
            message: "Success", data})
         } catch (error) {
          console.error("Error details:", error.response ? error.response.data : error.message);
          return res.status(500).json({ status : "failed", error: "Error from api" });
         }
  }

  const zlinkPanStatus = async (req,res)=>{
         const {ack_no} = req.body
         const endpoint = "/nsdl/pan-status"
         try {
           const data = await getDataFromZlinkPANApi(endpoint, {
            api_key : zlinkApiKey,
            ack_no 
           })
         
          return res.status(200).json({status : "Success",
            message: "Success", data})
         } catch (error) {
          console.error("Error details:", error.response ? error.response.data : error.message);
          return res.status(500).json({ status : "failed", error: "Error from api" });
         }
  }



// uti api start

  const zlinkUtiAgentOnbording = async (req,res)=>{
         const {name,agent_id,mobile,email_id,address,state,city,pincode,pan_no,aadhaar_no} = req.body
         const endpoint = "/uti/agent-onboarding"
         if(!name || !agent_id || !mobile || !email_id || !address || !state || !city || !pincode || !pan_no || !aadhaar_no)
         {
          return res.status(400).json({status : "failed", error: "Please fill all fields"})
         }
         try {
           const data = await getDataFromZlinkPANApi(endpoint, {
            token : Token,
            name,
            agent_id,
            mobile,
            email_id ,
            address ,
            state,
            city,
            pincode,
            pan_no,
            aadhaar_no
           })
         
          return res.status(200).json({status : "Success",
            message: "Success", data})
         } catch (error) {
          console.error("Error details:", error.response ? error.response.data : error.message);
          return res.status(500).json({ status : "failed", error: "Error from api" });
         }
  }

  const ZlinkUtiLogin = async (req,res)=>{
    const {agent_id} = req.body
    const endpoint = "/uti/login"
    if( !agent_id)
    {
     return res.status(400).json({status : "failed", error: "Please fill all fields"})
    }
    try {
      const data = await getDataFromZlinkPANApi(endpoint, {
       token : Token,
       agent_id,
       req_type: "LIVE"
     
      })
    
     return res.status(200).json({status : "Success",
       message: "Success", data})
    } catch (error) {
     console.error("Error details:", error.response ? error.response.data : error.message);
     return res.status(500).json({ status : "failed", error: "Error from api" });
    }
}


  module.exports = {
    zlinkBalance,
    zlinkNewPanRequest,
    zlinkCorrectionPanRequest,
    zlinkIncompletePan,
    zlinkPantxnStatus,
    zlinkPanStatus,
    zlinkUtiAgentOnbording,
    ZlinkUtiLogin

  }